find_w <- function(d1p, deriv1, sp){
  
  # sp = spline_poly
  # d1p = deriv1_poly
  # deriv1 = deriv1
  
  inflexion_points_deriv1 <- solve(d1p, b = 0, deriv = 1)                                       # Find inflexion points 1st deriv
  inflexion_points_deriv1_yval <- predict(d1p, inflexion_points_deriv1)
  w_poly_peaks <- c()                                                                           # Create vectors for w values to be stored
  w_poly_peaks_yval <- c()
  window <- list()                                                                              # Define 'window' as the timeframe you will look for peaks in
  p_p_distance <- c()
  
# Confirm first two peaks:
a <- 2
while(length(w_poly_peaks) < 2){

  first_window <- data.frame(inflexion_points_deriv1[1]:inflexion_points_deriv1[1+a], deriv1[inflexion_points_deriv1[1]:inflexion_points_deriv1[1+a]])
  inflexion_points_window_yval <- inflexion_points_deriv1_yval[which(inflexion_points_deriv1 > first_window[1, 1] & inflexion_points_deriv1 < first_window[, 1][length(first_window[, 1])])]
  inflexion_points_window <- inflexion_points_deriv1[which(inflexion_points_deriv1 > first_window[1, 1]  & inflexion_points_deriv1 < first_window[, 1][length(first_window[, 1])])]                      # Find inflection within the window from the greater array
  threshold <- quantile(first_window[, 2], probs=c(.95))                                                                                                                                                 # Define a threshold for finding peaks, of 0.95 
  window_poly_peaks <- which(inflexion_points_window_yval > threshold)       
  
  # Very occassionely, the second peak is below the threshold of 0.95, creating a leapfrog error
  # If the number of inflexion points is significant between the first two peaks aka leapfrog error has occurred, check there are no peaks in between that are in fact above threshold
  if(length(window_poly_peaks) == 2 & window_poly_peaks[2] - window_poly_peaks[1] > 40){
    confirm_no_missed_peaks_window <- data.frame(inflexion_points_deriv1[window_poly_peaks[1]+2]:inflexion_points_deriv1[window_poly_peaks[2]-2],   deriv1[inflexion_points_deriv1[window_poly_peaks[1]+2]:inflexion_points_deriv1[window_poly_peaks[2]-2]]  ) 
    inflexion_points_confirm_window_yval <- inflexion_points_deriv1_yval[which(inflexion_points_deriv1 > confirm_no_missed_peaks_window[1, 1] & inflexion_points_deriv1 < confirm_no_missed_peaks_window[, 1][length(confirm_no_missed_peaks_window[, 1])])]
    inflexion_points_confirm_window <- inflexion_points_deriv1[which(inflexion_points_deriv1 > confirm_no_missed_peaks_window[1, 1]  & inflexion_points_deriv1 < confirm_no_missed_peaks_window[, 1][length(confirm_no_missed_peaks_window[, 1])])]                      # Find inflection within the window from the greater array
    threshold <- quantile(confirm_no_missed_peaks_window[, 2], probs=c(.95))       
    peaks_missed <- inflexion_points_confirm_window[which(inflexion_points_confirm_window_yval > threshold)]
    # now match up the first missed peak to inflexion_points in first_window
    peaks_missed <- which(inflexion_points_window == peaks_missed[1])
    # now assign the first missed peak as the second window_poly_peak
    window_poly_peaks[2] <- peaks_missed[1]
  }
  
  # Also very occassionely, the first peak is double-peaked, so make sure peaks are not too close together:
  if(length(window_poly_peaks) == 2 & window_poly_peaks[2] - window_poly_peaks[1] < 5){
    window_poly_peaks <- window_poly_peaks[-2]   # this line removes the second element, allowing a third to become the second
  }
  
  # Find which inflection points are above threshold
  window_poly_peaks_yval <- inflexion_points_window_yval[window_poly_peaks]
  window_poly_peaks <- inflexion_points_window[window_poly_peaks]     
  #plot(first_window, type = "l")
  #points(window_poly_peaks, window_poly_peaks_yval, pch = 19)
  
  # This is a special case for when the first legitimate peak happens to have 3 very close together inflection points
  if(length(window_poly_peaks) > 2 & (window_poly_peaks[3] - window_poly_peaks[1] < 1)){
      window_poly_peaks <- window_poly_peaks[-c(1, 3)]
  }
  
  m <- mean(inflexion_points_deriv1_yval[1:(1+a)])       # Calculate mean and SD of inflection points within the window
  sd <- sd(inflexion_points_deriv1_yval[1:(1+a)])
  
  if(length(window_poly_peaks) == 2){                    # If two peaks are found, confirm that they are both significantly higher than surrounding inflection points,                                                                                  
    if(window_poly_peaks_yval[1] > (m + (1.5*sd)) & window_poly_peaks_yval[1] > (mean(deriv1)+sd(deriv1))){      # and that the second peak is greater than half the height of the first peak (unless the first peak is an artefact)
      w_poly_peaks[1] <-  window_poly_peaks[1]   
      if(window_poly_peaks_yval[2] > (m + (1.5*sd)) & window_poly_peaks_yval[2] > (window_poly_peaks_yval[1]/2) | window_poly_peaks_yval[1] > (mean(deriv1) + (5*sd(deriv1)))){  
        w_poly_peaks[2] <-  window_poly_peaks[2]                                                                                                                          
      }
    }
  }
  
  if(length(window_poly_peaks) > 3){      # If more than 3 peaks identified, assume the time series begins with an artefact and skip forward
    inflexion_points_deriv1 <- inflexion_points_deriv1[-c(1:100)]
    inflexion_points_deriv1_yval <- inflexion_points_deriv1_yval[-c(1:100)]
    a <- -3  # reset a
  }
  
  a <- a + 5      # Widen the window looking for two peaks and continue increasing until two legitimate peaks are found
}


# Find remaining peaks based on p_p distance:
artefacts <- c()
# Calculate mean and SD of inflection points generally
m <- mean(inflexion_points_deriv1_yval)       
sd <- sd(inflexion_points_deriv1_yval)
for(i in 3:length(inflexion_points_deriv1)){   # length(inflexion_points_deriv1)
    p_p_distance[i] <- w_poly_peaks[length(w_poly_peaks)] - w_poly_peaks[length(w_poly_peaks)-1]   # p_p_distance defined as distance between two previous peaks
    if(p_p_distance[i] > (mean(p_p_distance[!is.na(p_p_distance)])*2)){    # if p_p_distance is unusually, this can be because there was a large gap between an artefact and the next legitimate peak 
      p_p_distance[i] <- p_p_distance[3]      # correct any abnormal p_p_distances to avoid leapfrogging
    }
    if((w_poly_peaks[length(w_poly_peaks)] + (4*p_p_distance[i]) > length(deriv1))){                            # If the next window goes beyond the length of the data, break the loop
      break
    }                                      
    window_poly_peaks <- c()
    window_extension <- 1.35
    window_beginning <- 0.5
    printed <- NA
    # Adjust mean and standard deviation to remove any artefacts that have been identified
    if(length(artefacts) > 0){
      remove <- c()
      for(j in artefacts[which(artefacts < length(w_poly_peaks))]){
        remove[j] <- which(abs(inflexion_points_deriv1 - w_poly_peaks[j]) == min(abs(inflexion_points_deriv1 - w_poly_peaks[j])))
      }
      remove <- remove[!is.na(remove)]
      new_remove <- c()
      for(j in 1:length(remove)){
        new_remove[(length(new_remove)+1):(length(new_remove)+21)] <- (remove[j] -10): (remove[j] + 10)   # remove inflection points around artefact peaks
      }
      if(sum(new_remove < 1) > 0){  # running whats inside the for loop will result in a null new_remove vector so only run it if there are in fact negative / 0 values in new_remove
        new_remove <- new_remove[-(which(new_remove < 1))] 
      }    
      m <- mean(inflexion_points_deriv1_yval[-new_remove])       
      sd <- sd(inflexion_points_deriv1_yval[-new_remove])  
    }
    
    while(length(window_poly_peaks) < 1){
      
       if(window_extension > 10){
         window_beginning <- 2
         window_extension <- 2.5
       }
      
       window[[i]] <- data.frame((w_poly_peaks[length(w_poly_peaks)] + window_beginning*p_p_distance[i]):(w_poly_peaks[length(w_poly_peaks)] + window_extension*p_p_distance[i]),  deriv1[(w_poly_peaks[length(w_poly_peaks)] + window_beginning*p_p_distance[i]):(w_poly_peaks[length(w_poly_peaks)] + window_extension*p_p_distance[i])])    # window initially defined as (the previous peak + 0.5*p_p_distance) to (previous peak + 1.35*p_p_distance)
       inflexion_points_window_yval <- inflexion_points_deriv1_yval[which(inflexion_points_deriv1 > window[[i]][1, 1] & inflexion_points_deriv1 < window[[i]][length(window[[i]][, 1]), 1])]
       inflexion_points_window <- inflexion_points_deriv1[which(inflexion_points_deriv1 > window[[i]][1, 1] & inflexion_points_deriv1 < window[[i]][length(window[[i]][, 1]), 1])]                          
       threshold <- quantile(window[[i]][, 2], probs=c(0.95))           # If the window is somehow too long for the time series, this line will spring an error                                 
       window_poly_peaks <- which(inflexion_points_window_yval > threshold)                      
       window_poly_peaks_yval <- inflexion_points_window_yval[window_poly_peaks]
       window_poly_peaks <- inflexion_points_window[window_poly_peaks]     

         #plot(window[[i]], type = "l")
         #points(window_poly_peaks, window_poly_peaks_yval, pch = 19)

         
       if(length(window_poly_peaks) > 2){                  # If three peaks are identified, this can be due to four reasons: 1. a window does not include a genuine peak (so there are multiple secondary ones of similar height) 2. there is an artefact that causes three peaks to be in the same window 3. there are significantly large secondary peaks that they also exceed the threshold for identification 4. the peak of the 1st derivative itself has multiple inflection points e.g in participant 38 this occurs                                                                                                               # If the these criteria are met, go to the next loop
         if(max(window_poly_peaks_yval) > (m+(2*sd)) |  max(window_poly_peaks_yval) > (mean(deriv1[window_poly_peaks[1]:(window_poly_peaks[1] + (3*p_p_distance[i]))]) + 2*sd(deriv1[window_poly_peaks[1]:(window_poly_peaks[1] + (3*p_p_distance[i]))]))  ){        # If peaks are high, include the highest one as a peak. Mark it as an artefact if the other two peaks exceed m+(2*sd) aka are not secondary peaks. 
           w_poly_peaks[length(w_poly_peaks)+1] <- window_poly_peaks[which(window_poly_peaks_yval == max(window_poly_peaks_yval))]  # Mark max peak as a peak
           not_max_peaks <- window_poly_peaks_yval[order(window_poly_peaks_yval)[1:2]]  # Find the two lowest peaks
           if(not_max_peaks[1] > m+(2*sd) & not_max_peaks[2] > m+(2*sd) & (window_poly_peaks[3] - window_poly_peaks[1]) > (p_p_distance[i]/10)){    # If the two lower peaks are also high, and not so close together as to be multiple inflection points on the same peak, label the peak as an artefact. 
             cat('\n','Potential artefact',  ', plot(', (w_poly_peaks[i-1]-100), ':', (w_poly_peaks[i-1]+300), ', deriv1[', (w_poly_peaks[i-1]-100), ':', (w_poly_peaks[i-1]+300), '], type = "l") ,', 'wave', i, '+/- 2 removed because the non-max peaks were high') 
             artefacts[length(artefacts) + c(1, 2, 3, 4, 5)] <- c(i-2, i-1, i, i+1, i+2) 
           }
         }else{                                           # If peaks are low, assume they are secondary and extend the window
           window_extension <- window_extension + 0.5
           window_poly_peaks <- c()
         }
       }
       
       
       if(length(window_poly_peaks) == 2){
         if(max(window_poly_peaks_yval) > (m+(2*sd)) | max(window_poly_peaks_yval) > (mean(deriv1[window_poly_peaks[1]:(window_poly_peaks[1] + (3*p_p_distance[i]))]) + 2*sd(deriv1[window_poly_peaks[1]:(window_poly_peaks[1] + (3*p_p_distance[i]))])) ){   # at least one of the peaks high?    (occassionely there is a series of low amplitude waves that are far below average for the time series, to account for this there is also a test of height relative to the peaks local to it)
           if((window_poly_peaks[2] - window_poly_peaks[1]) < (p_p_distance[i]/3)){   # peaks close togetber?
             w_poly_peaks[length(w_poly_peaks)+1] <- window_poly_peaks[which(window_poly_peaks_yval == max(window_poly_peaks_yval))]  # If they are, take the highest peak and mark it as an artefact
             cat('\n','Potential artefact',  ', plot(', (w_poly_peaks[i-1]-100), ':', (w_poly_peaks[i-1]+300), ', deriv1[', (w_poly_peaks[i-1]-100), ':', (w_poly_peaks[i-1]+300), '], type = "l") ,', 'wave', i, '+/- 2 removed because two peaks found too close together') 
           }else{      # If peaks are not too close together..
             if((window_poly_peaks_yval[1] > (m+(2*sd))) | window_poly_peaks_yval[1] > (mean(deriv1[window_poly_peaks[1]:(window_poly_peaks[1] + (3*p_p_distance[i]))]) + 2*sd(deriv1[window_poly_peaks[1]:(window_poly_peaks[1] + (3*p_p_distance[i]))])) & window_poly_peaks_yval[1] > (window_poly_peaks_yval[2]/2)){ # Check if first peak is legit by 1. comparing to m+(2*sd)  or 2. 
               w_poly_peaks[length(w_poly_peaks)+1] <- window_poly_peaks[1]    # If so mark it as a peak
               if(window_poly_peaks_yval[2] > (m+(2*sd)) |  window_poly_peaks_yval[2] > (mean(deriv1[window_poly_peaks[1]:(window_poly_peaks[1] + (3*p_p_distance[i]))]) + 2*sd(deriv1[window_poly_peaks[1]:(window_poly_peaks[1] + (3*p_p_distance[i]))]))  & window_poly_peaks_yval[2] > (window_poly_peaks_yval[1]/2)){   # and check if the second one is legit...
                 w_poly_peaks[length(w_poly_peaks)+1] <- window_poly_peaks[2]  # and if so mark it also as a a peak
               }
             }else{   # If first peak is not legit
               if(window_poly_peaks_yval[2] > (m+(2*sd)) | window_poly_peaks_yval[2] > (mean(deriv1[window_poly_peaks[1]:(window_poly_peaks[1] + (3*p_p_distance[i]))]) + 2*sd(deriv1[window_poly_peaks[1]:(window_poly_peaks[1] + (3*p_p_distance[i]))]))  & window_poly_peaks_yval[2] > (window_poly_peaks_yval[1]/2)){
                 w_poly_peaks[length(w_poly_peaks)+1] <- window_poly_peaks[2] 
               }
             }
           }
         }else{     # If peaks not high, extend window
           window_extension <- window_extension + 0.5
           window_poly_peaks <- c()
         }   
       }
       
       
       if(length(window_poly_peaks) == 1){                # If one peak is identified, confirm 1. that the peak is sufficiently high so as not to be a secondary peak 
         if(window_poly_peaks_yval > (m+(2*sd)) | window_poly_peaks_yval > (mean(deriv1[window_poly_peaks[1]:(window_poly_peaks[1] + (3*p_p_distance[i]))]) + 2*sd(deriv1[window_poly_peaks[1]:(window_poly_peaks[1] + (3*p_p_distance[i]))])) | window_poly_peaks_yval > (predict(d1p, w_poly_peaks[i-1])*0.9)  ){                                                                                                                           
           w_poly_peaks[length(w_poly_peaks)+1] <- window_poly_peaks 
           }else{
             if((i-1) %in% artefacts){
               w_poly_peaks[length(w_poly_peaks)+1] <- window_poly_peaks 
             }else{
               window_extension <- window_extension + 0.5
               window_poly_peaks <- c()
             }
         }
       }
       
       if(window_extension > 2 & is.na(printed)){        # If the window has been extended more than twice to find a peak, it is likely that that peak may be an artefact; label it as such
         cat('\n','Potential artefact',  ', plot(', (w_poly_peaks[i-1]-100), ':', (w_poly_peaks[i-1]+300), ', deriv1[', (w_poly_peaks[i-1]-100), ':', (w_poly_peaks[i-1]+300), '], type = "l") ,', 'wave', i, '+/- 2 removed because window needed extending')  # i-1 because w_poly_peaks[i] doesn't exist yet - as such the range has also been adjusted
         printed <- 1 
         artefacts[length(artefacts) + c(1, 2, 3, 4, 5)] <- c(i-2, i-1, i, i+1, i+2)
       }
       
       if(min(window[[i]]) < (m-(3*sd)) & is.na(printed)){   # If a window contains a value that drops considerably below the mean, label the peak found in that window as an artefact 
         cat('\n','Potential artefact',  ', plot(', (w_poly_peaks[i-1]-100), ':', (w_poly_peaks[i-1]+300), ', deriv1[', (w_poly_peaks[i-1]-100), ':', (w_poly_peaks[i-1]+300), '], type = "l") ,', 'wave', i, '+/- 2 removed because the window contains a very low value') 
         artefacts[length(artefacts) + c(1, 2, 3, 4, 5)] <- c(i-2, i-1, i, i+1, i+2)
       }
  
       window_extension <- window_extension + 0.1   # If no peaks are found in a window (or only spurious ones found) extend the window and look again
    }
}                                                                                                                         
w_poly_peaks_yval_deriv1 <- predict(d1p, w_poly_peaks)
#Find m and sd for w_poly_peaks:
m <- mean(w_poly_peaks_yval_deriv1) 
sd <- sd(w_poly_peaks_yval_deriv1) 
# Redefine w_poly_peaks as without artefacts
if(length(artefacts) > 0){
  w_poly_peaks <- w_poly_peaks[-artefacts]
  w_poly_peaks_yval_deriv1 <- w_poly_peaks_yval_deriv1[-artefacts]
}
# Now that all peaks have been found, and artefacts removed, go through once more to look for any unusually tall peaks, and label them as artefacts
artefacts <- c()
for(i in 2:(length(w_poly_peaks)-1)){     
  if(w_poly_peaks_yval_deriv1[i] > 1.5*w_poly_peaks_yval_deriv1[i+1] & w_poly_peaks_yval_deriv1[i] > 1.5*w_poly_peaks_yval_deriv1[i-1] | w_poly_peaks_yval_deriv1[i] > (m+(5*sd))){  # consider too tall if greater than 1.5* the wave before and the wave after OR greater than (m+(5*sd)) 
    cat('\n','Potential artefact',  ', plot(', (w_poly_peaks[i-1]-100), ':', (w_poly_peaks[i-1]+300), ', deriv1[', (w_poly_peaks[i-1]-100), ':', (w_poly_peaks[i-1]+300), '], type = "l") ,', 'wave', i, '+/- 2 removed because of a very tall peak')
    artefacts[length(artefacts) + c(1, 2, 3, 4, 5)] <- c(i-2, i-1, i, i+1, i+2)
  }
  if(i > 5 & i < (length(w_poly_peaks)-5)){
    if(w_poly_peaks_yval_deriv1[i] > (1.5*mean(w_poly_peaks_yval_deriv1[c((i-5):(i+5))]))){
      cat('\n','Potential artefact',  ', plot(', (w_poly_peaks[i-1]-100), ':', (w_poly_peaks[i-1]+300), ', deriv1[', (w_poly_peaks[i-1]-100), ':', (w_poly_peaks[i-1]+300), '], type = "l") ,', 'wave', i, '+/- 2 removed because of a very tall peak')   # Another check which can only be carried out on waves that have 5 either side of them, is to check if the ith wave is greater than 1.5 x the mean of peaks i-5 to i+5
      artefacts[length(artefacts) + c(1, 2, 3, 4, 5)] <- c(i-2, i-1, i, i+1, i+2)
    }
  }
}       
# Find W y_values on original trace
w_poly_peaks_yval <- predict(sp, w_poly_peaks)  
# Create dataframe 
Ws <- data.frame(w_poly_peaks, w_poly_peaks_yval, w_poly_peaks_yval_deriv1)
if(length(artefacts) > 0){
  Ws <- Ws[-artefacts, ]
}
Ws <- Ws[-1, ]
Ws <-Ws[-nrow(Ws), ]
 return(Ws)
}
