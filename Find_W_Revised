find_w <- function(d1p){
  
  inflexion_points_deriv1 <- solve(d1p, b = 0, deriv = 1)                                       # Find inflexion points 1st deriv
  inflexion_points_deriv1_yval <- predict(d1p, inflexion_points_deriv1)
  w_poly_peaks <- c()                                                                           # Create vectors for w values to be stored
  w_poly_peaks_yval <- c()
  window <- list()                                                                              # Define 'window' as the timeframe you will look for peaks in
  
# Confirm first two peaks:
  
a <- 10
while(length(w_poly_peaks) < 2){

  first_window <- data.frame(inflexion_points_deriv1[1]:inflexion_points_deriv1[1+a], deriv1[inflexion_points_deriv1[1]:inflexion_points_deriv1[1+a]])
  inflexion_points_window_yval <- inflexion_points_deriv1_yval[which(inflexion_points_deriv1 > first_window[1, 1] & inflexion_points_deriv1 < first_window[, 1][length(first_window[, 1])])]
  inflexion_points_window <- inflexion_points_deriv1[which(inflexion_points_deriv1 > first_window[1, 1]  & inflexion_points_deriv1 < first_window[, 1][length(first_window[, 1])])]                      # Find inflection within the window from the greater array
  threshold <- quantile(first_window[, 2], probs=c(.95))                                                                                                                                                 # Define a threshold for finding peaks, initially of 0.95 
  window_poly_peaks <- which(inflexion_points_window_yval > threshold)                                                                                                                                   # Find which inflection points are above threshold
  window_poly_peaks_yval <- inflexion_points_window_yval[window_poly_peaks]
  window_poly_peaks <- inflexion_points_window[window_poly_peaks]     
  #plot(first_window)
  #points(window_poly_peaks, window_poly_peaks_yval, pch = 19)
  
  m <- mean(inflexion_points_deriv1_yval[1:(1+a)])                                              # Calculate mean and SD of inflection points within the window
  sd <- sd(inflexion_points_deriv1_yval[1:(1+a)])
  
  if(length(window_poly_peaks) == 2){                                                           # If two peaks are found, confirm that they are both significantly higher than surrounding inflection points,                                                                                  
    if(window_poly_peaks_yval[1] > (m + (1.5*sd))){                                             # and that the second peak is greater than half the heigh of the first peak
      w_poly_peaks[1] <-  window_poly_peaks[1]                                                                                                                           
    }
    if(window_poly_peaks_yval[2] > (m + (1.5*sd)) & window_poly_peaks_yval[2] > (window_poly_peaks_yval[1]/2)){  
      w_poly_peaks[2] <-  window_poly_peaks[2]                                                                                                                          
    }
  }
  a <- a + 5                                                                                    # Widen the window looking for two peaks and continue increasing until two legitimate peaks are found
}


# Find remaining peaks based on p_p distance:

for(i in 3:length(inflexion_points_deriv1)){ 
    switch <- 0                                                                                 # Switch is used as an artifact tracker, automatically set to 0
    if((w_poly_peaks[length(w_poly_peaks)] + 100 > length(deriv1))){                            # If the next window goes beyond the length of the data, break the loop
      break
    }                                      
    p_p_distance <- w_poly_peaks[length(w_poly_peaks)] - w_poly_peaks[length(w_poly_peaks)-1]   # p_p_distance defined as distance between two previous peaks
    window[[i]] <- data.frame((w_poly_peaks[length(w_poly_peaks)] + 0.75*p_p_distance):(w_poly_peaks[length(w_poly_peaks)] + 1.25*p_p_distance),  deriv1[(w_poly_peaks[length(w_poly_peaks)] + 0.75*p_p_distance):(w_poly_peaks[length(w_poly_peaks)] + 1.25*p_p_distance)])    # window defined as (the previous peak + 0.75*p_p_distance) to (previous peak + 1.25*p_p_distance)
    if(i > 3){
      if(window[[c(i, 1)]][1] == window[[c(i-1, 1)]][1]){                                                                                                                                                                         # If the window is the same as the previous window (which would happen if no peaks were defined in a loop i.e in the case of artifact), 
        window[[i]] <- data.frame((w_poly_peaks[length(w_poly_peaks)] + 200):(w_poly_peaks[length(w_poly_peaks)] + 300), deriv1[(w_poly_peaks[length(w_poly_peaks)] + 200):(w_poly_peaks[length(w_poly_peaks)] + 300)])           # then the window is redefined as being (last peak + 200) to (last peak + 300)
        switch <- 1                                                                                                                                                                                                               # Switch is also redefined as 1, and will be used as an indicator that the windowing has had to 'restart'
      }
    }
    window_poly_peaks <- c()
    
    probs_threshold <- 0.95                                                                     # Within each window, start at threshold of 0.95 and reduce by 0.05 until peak found (threshold is stopped from reducing below 0.8)
    while(length(window_poly_peaks) < 1){
      
      inflexion_points_window_yval <- inflexion_points_deriv1_yval[which(inflexion_points_deriv1 > window[[i]][1, 1] & inflexion_points_deriv1 < window[[i]][length(window[[i]][, 1]), 1])]
      inflexion_points_window <- inflexion_points_deriv1[which(inflexion_points_deriv1 > window[[i]][1, 1] & inflexion_points_deriv1 < window[[i]][length(window[[i]][, 1]), 1])]                          
      threshold <- quantile(window[[i]][, 2], probs=c(probs_threshold))                                            
      window_poly_peaks <- which(inflexion_points_window_yval > threshold)                      
      window_poly_peaks_yval <- inflexion_points_window_yval[window_poly_peaks]
      window_poly_peaks <- inflexion_points_window[window_poly_peaks]     
      #plot(window[[i]])
      #points(window_poly_peaks, window_poly_peaks_yval, pch = 19)
      
      if(length(window_poly_peaks) == 2){                                                                                                # If two peaks are found, and they are not next to each other, add them both
        if((window_poly_peaks[2] - window_poly_peaks[1]) > 10){
          w_poly_peaks[(length(w_poly_peaks)+1):(length(w_poly_peaks) + length(window_poly_peaks))] <-  window_poly_peaks 
          w_poly_peaks_yval[(length(w_poly_peaks)+1):(length(w_poly_peaks) + length(window_poly_peaks))] <- window_poly_peaks_yval
        }
      }
      
      if(length(window_poly_peaks) == 1){                                                                                                # If one peak is found:
        if(window_poly_peaks_yval < max(window[[i]]) & (window_poly_peaks - w_poly_peaks[length(w_poly_peaks)]) < p_p_distance*0.75){    # Assume peak is spurious if it is not the maximum value and the distance of the found peak from the last peak is less than 0.75*p_p_distance (i.e likely to be a secondary peak)
          break                                                                                                                          # If the these criteria are met, go to the next loop
        }
        w_poly_peaks[length(w_poly_peaks)+1] <- window_poly_peaks     
      }
      
      probs_threshold <- probs_threshold - 0.05
      if(probs_threshold < 0.8){
        break
      }
    }
    if(switch == 1){                                        # If switch = 1, notify of potential artifact
      cat('\n', 'Potential artifact at peak', i)
    }
}                                                                                                                         
w_poly_peaks_yval <- predict(d1p, w_poly_peaks)                                                                                                              
w_poly_peaks_yval_deriv1 <- predict(d1p, w_poly_peaks)
Ws <- data.frame(w_poly_peaks, w_poly_peaks_yval, w_poly_peaks_yval_deriv1)
 return(Ws)
}
  

