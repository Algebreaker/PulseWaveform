find_w <- function(d1p){
  
  inflexion_points_deriv1 <- solve(d1p, b = 0, deriv = 1)                                       # Find inflexion points 1st deriv
  inflexion_points_deriv1_yval <- predict(d1p, inflexion_points_deriv1)
  w_poly_peaks <- c()                                                                           # Create vectors for w values to be stored
  w_poly_peaks_yval <- c()
  window <- list()                                                                              # Define 'window' as the timeframe you will look for peaks in
  
# Confirm first two peaks:
  
a <- 10
while(length(w_poly_peaks) < 2){

  first_window <- data.frame(inflexion_points_deriv1[1]:inflexion_points_deriv1[1+a], deriv1[inflexion_points_deriv1[1]:inflexion_points_deriv1[1+a]])
  inflexion_points_window_yval <- inflexion_points_deriv1_yval[which(inflexion_points_deriv1 > first_window[1, 1] & inflexion_points_deriv1 < first_window[, 1][length(first_window[, 1])])]
  inflexion_points_window <- inflexion_points_deriv1[which(inflexion_points_deriv1 > first_window[1, 1]  & inflexion_points_deriv1 < first_window[, 1][length(first_window[, 1])])]                      # Find inflection within the window from the greater array
  threshold <- quantile(first_window[, 2], probs=c(.95))                                                                                                                                                 # Define a threshold for finding peaks, initially of 0.95 
  window_poly_peaks <- which(inflexion_points_window_yval > threshold)                                                                                                                                   # Find which inflection points are above threshold
  window_poly_peaks_yval <- inflexion_points_window_yval[window_poly_peaks]
  window_poly_peaks <- inflexion_points_window[window_poly_peaks]     
  #plot(first_window)
  #points(window_poly_peaks, window_poly_peaks_yval, pch = 19)
  
  m <- mean(inflexion_points_deriv1_yval[1:(1+a)])       # Calculate mean and SD of inflection points within the window
  sd <- sd(inflexion_points_deriv1_yval[1:(1+a)])
  
  if(length(window_poly_peaks) == 2){                    # If two peaks are found, confirm that they are both significantly higher than surrounding inflection points,                                                                                  
    if(window_poly_peaks_yval[1] > (m + (1.5*sd))){      # and that the second peak is greater than half the heigh of the first peak
      w_poly_peaks[1] <-  window_poly_peaks[1]                                                                                                                           
    }
    if(window_poly_peaks_yval[2] > (m + (1.5*sd)) & window_poly_peaks_yval[2] > (window_poly_peaks_yval[1]/2)){  
      w_poly_peaks[2] <-  window_poly_peaks[2]                                                                                                                          
    }
  }
  a <- a + 5      # Widen the window looking for two peaks and continue increasing until two legitimate peaks are found
}


# Find remaining peaks based on p_p distance:

for(i in 3:length(inflexion_points_deriv1)){  #length(inflexion_points_deriv1)
    if((w_poly_peaks[length(w_poly_peaks)] + 100 > length(deriv1))){                            # If the next window goes beyond the length of the data, break the loop
      break
    }                                      
    p_p_distance <- w_poly_peaks[length(w_poly_peaks)] - w_poly_peaks[length(w_poly_peaks)-1]   # p_p_distance defined as distance between two previous peaks
    window_poly_peaks <- c()
    
    window_extension <- 1.35                                                # Define the window beginning and end point in units of p_p_distance
    window_beginning <- 0.5                                                 # These, rather than the threshold, will now change if a peak is not found
    printed <- NA
    while(length(window_poly_peaks) < 1){
      
      
       window[[i]] <- data.frame((w_poly_peaks[length(w_poly_peaks)] + window_beginning*p_p_distance):(w_poly_peaks[length(w_poly_peaks)] + window_extension*p_p_distance),  deriv1[(w_poly_peaks[length(w_poly_peaks)] + window_beginning*p_p_distance):(w_poly_peaks[length(w_poly_peaks)] + window_extension*p_p_distance)])    
       
       inflexion_points_window_yval <- inflexion_points_deriv1_yval[which(inflexion_points_deriv1 > window[[i]][1, 1] & inflexion_points_deriv1 < window[[i]][length(window[[i]][, 1]), 1])]
       inflexion_points_window <- inflexion_points_deriv1[which(inflexion_points_deriv1 > window[[i]][1, 1] & inflexion_points_deriv1 < window[[i]][length(window[[i]][, 1]), 1])]                          
       threshold <- quantile(window[[i]][, 2], probs=c(0.95))                                            
       window_poly_peaks <- which(inflexion_points_window_yval > threshold)                       # Lines 56-63 are equivalent to 14-22
       window_poly_peaks_yval <- inflexion_points_window_yval[window_poly_peaks]
       window_poly_peaks <- inflexion_points_window[window_poly_peaks]     
       #plot(window[[i]])
       #points(window_poly_peaks, window_poly_peaks_yval, pch = 19)
       
       if(length(window_poly_peaks) > 2){                                    # So far from what I have seen, if there are more than 3 'peaks' picked up 
         window_beginning <- window_beginning + 0.5                          # within a window its because a peak is not in the window.                                                                                                        
         window_extension <- window_extension + 0.5                          # The general idea is that the windows start small and get bigger. 
         window_poly_peaks <- c()                                            
       }
       
       if(length(window_poly_peaks) == 2){
         if((window_poly_peaks[2] - window_poly_peaks[1]) > (p_p_distance/2) & window_poly_peaks_yval[1] > m){                              # If two peaks are found, check they are 1. not too close together, 
           w_poly_peaks[(length(w_poly_peaks)+1):(length(w_poly_peaks) + length(window_poly_peaks))] <-  window_poly_peaks                  # and 2. above the mean, to confirm them as peaks. 
           w_poly_peaks_yval[(length(w_poly_peaks)+1):(length(w_poly_peaks) + length(window_poly_peaks))] <- window_poly_peaks_yval
         }else if(length(window_poly_peaks) == 2){
           window_poly_peaks <- c()
         }
       }
          
       if(length(window_poly_peaks) == 1){                                                                                                  # If one peak is found, check if its a secondary peak by  
         if(window_poly_peaks_yval < (m+sd) & window_poly_peaks_yval < (w_poly_peaks[length(w_poly_peaks)]/2)){                             # 1. being below the SD, and 2. being less than half the height of the previous peak
           window_beginning <- window_beginning + 0.5                                                                                       # If it is identified as a secondary peak, move the window further along the x-axis.                                  
           window_extension <- window_extension + 0.5
           window_poly_peaks <- c()
           }else{
           w_poly_peaks[length(w_poly_peaks)+1] <- window_poly_peaks 
         }
       }
       
       window_extension <- window_extension + 0.1                          # extend the window every time a correct peak is not found 
       
       if(window_extension > 2 & is.na(printed)){                          # If the window has had to be adjusted significantly, this could be because of an artefact; mark it as such. 
         cat('\n','Potential artefact at', w_poly_peaks[i], ', plot(', (w_poly_peaks[i]-200), ':', (w_poly_peaks[i]+200), ', deriv1[', (w_poly_peaks[i]-200), ':', (w_poly_peaks[i]+200), '], type = "l") ?')
         printed <- 1 
       }
    }
    
}                                                                                                                         
w_poly_peaks_yval <- predict(d1p, w_poly_peaks)                                                                                                              
w_poly_peaks_yval_deriv1 <- predict(d1p, w_poly_peaks)
Ws <- data.frame(w_poly_peaks, w_poly_peaks_yval, w_poly_peaks_yval_deriv1)
 return(Ws)
}
