find_w <- function(d1p){
  
  inflexion_points_deriv1 <- solve(d1p, b = 0, deriv = 1)                                       # Find inflexion points 1st deriv
  inflexion_points_deriv1_yval <- predict(d1p, inflexion_points_deriv1)
  w_poly_peaks <- c()                                                                           # Create vectors for w values to be stored
  w_poly_peaks_yval <- c()
  window <- list()                                                                              # Define 'window' as the timeframe you will look for peaks in
  
# Confirm first two peaks:
  
a <- 10
while(length(w_poly_peaks) < 2){

  first_window <- data.frame(inflexion_points_deriv1[1]:inflexion_points_deriv1[1+a], deriv1[inflexion_points_deriv1[1]:inflexion_points_deriv1[1+a]])
  inflexion_points_window_yval <- inflexion_points_deriv1_yval[which(inflexion_points_deriv1 > first_window[1, 1] & inflexion_points_deriv1 < first_window[, 1][length(first_window[, 1])])]
  inflexion_points_window <- inflexion_points_deriv1[which(inflexion_points_deriv1 > first_window[1, 1]  & inflexion_points_deriv1 < first_window[, 1][length(first_window[, 1])])]                      # Find inflection within the window from the greater array
  threshold <- quantile(first_window[, 2], probs=c(.95))                                                                                                                                                 # Define a threshold for finding peaks, initially of 0.95 
  window_poly_peaks <- which(inflexion_points_window_yval > threshold)                                                                                                                                   # Find which inflection points are above threshold
  window_poly_peaks_yval <- inflexion_points_window_yval[window_poly_peaks]
  window_poly_peaks <- inflexion_points_window[window_poly_peaks]     
  #plot(first_window)
  #points(window_poly_peaks, window_poly_peaks_yval, pch = 19)
  
  m <- mean(inflexion_points_deriv1_yval[1:(1+a)])       # Calculate mean and SD of inflection points within the window
  sd <- sd(inflexion_points_deriv1_yval[1:(1+a)])
  
  if(length(window_poly_peaks) == 2){                    # If two peaks are found, confirm that they are both significantly higher than surrounding inflection points,                                                                                  
    if(window_poly_peaks_yval[1] > (m + (1.5*sd))){      # and that the second peak is greater than half the heigh of the first peak
      w_poly_peaks[1] <-  window_poly_peaks[1]                                                                                                                           
    }
    if(window_poly_peaks_yval[2] > (m + (1.5*sd)) & window_poly_peaks_yval[2] > (window_poly_peaks_yval[1]/2)){  
      w_poly_peaks[2] <-  window_poly_peaks[2]                                                                                                                          
    }
  }
  a <- a + 5      # Widen the window looking for two peaks and continue increasing until two legitimate peaks are found
}


# Find remaining peaks based on p_p distance:
artefacts <- c()
for(i in 3:length(inflexion_points_deriv1)){   
    if((w_poly_peaks[length(w_poly_peaks)] + 100 > length(deriv1))){                            # If the next window goes beyond the length of the data, break the loop
      break
    }                                      
    p_p_distance <- w_poly_peaks[length(w_poly_peaks)] - w_poly_peaks[length(w_poly_peaks)-1]   # p_p_distance defined as distance between two previous peaks
    window_poly_peaks <- c()
    
    window_extension <- 1.35
    window_beginning <- 0.5
    printed <- NA
    while(length(window_poly_peaks) < 1){
      
      
       window[[i]] <- data.frame((w_poly_peaks[length(w_poly_peaks)] + window_beginning*p_p_distance):(w_poly_peaks[length(w_poly_peaks)] + window_extension*p_p_distance),  deriv1[(w_poly_peaks[length(w_poly_peaks)] + window_beginning*p_p_distance):(w_poly_peaks[length(w_poly_peaks)] + window_extension*p_p_distance)])    # window defined as (the previous peak + 0.75*p_p_distance) to (previous peak + 1.25*p_p_distance)
       
       inflexion_points_window_yval <- inflexion_points_deriv1_yval[which(inflexion_points_deriv1 > window[[i]][1, 1] & inflexion_points_deriv1 < window[[i]][length(window[[i]][, 1]), 1])]
       inflexion_points_window <- inflexion_points_deriv1[which(inflexion_points_deriv1 > window[[i]][1, 1] & inflexion_points_deriv1 < window[[i]][length(window[[i]][, 1]), 1])]                          
       threshold <- quantile(window[[i]][, 2], probs=c(0.95))                                            
       window_poly_peaks <- which(inflexion_points_window_yval > threshold)                      
       window_poly_peaks_yval <- inflexion_points_window_yval[window_poly_peaks]
       window_poly_peaks <- inflexion_points_window[window_poly_peaks]     
       #plot(window[[i]])
       #points(window_poly_peaks, window_poly_peaks_yval, pch = 19)
       
       if(length(window_poly_peaks) > 2){    # for cases where 3 incorrect peaks are picked up
         window_beginning <- window_beginning + 0.5                                                                                                                            # If the these criteria are met, go to the next loop
         window_extension <- window_extension + 0.5
         window_poly_peaks <- c()
       }
       
       if(length(window_poly_peaks) == 2){
         if((window_poly_peaks[2] - window_poly_peaks[1]) > (p_p_distance/4) & window_poly_peaks_yval[1] > m){
           w_poly_peaks[(length(w_poly_peaks)+1):(length(w_poly_peaks) + length(window_poly_peaks))] <-  window_poly_peaks 
           w_poly_peaks_yval[(length(w_poly_peaks)+1):(length(w_poly_peaks) + length(window_poly_peaks))] <- window_poly_peaks_yval
         }else if(length(window_poly_peaks) == 2){
           window_poly_peaks <- c()
         }
       }
          
      
       if(length(window_poly_peaks) == 1){                                                                                                # If one peak is found:
         if(window_poly_peaks_yval < (m+sd) & window_poly_peaks_yval < (w_poly_peaks[length(w_poly_peaks)]/2)){    # Assume peak is spurious if it is not the maximum value and the distance of the found peak from the last peak is less than 0.75*p_p_distance (i.e likely to be a secondary peak) # window_poly_peaks_yval < max(window[[i]][2]) & (window_poly_peaks - w_poly_peaks[length(w_poly_peaks)]) < p_p_distance*0.5
           window_beginning <- window_beginning + 0.5                                                                                                                            # If the these criteria are met, go to the next loop
           window_extension <- window_extension + 0.5
           window_poly_peaks <- c()
           }else{
           w_poly_peaks[length(w_poly_peaks)+1] <- window_poly_peaks 
         }
       }
       
       window_extension <- window_extension + 0.1
       
       if(window_extension > 2 & is.na(printed)){
         cat('\n','Potential artefact at', w_poly_peaks[i], ', plot(', (w_poly_peaks[i]-200), ':', (w_poly_peaks[i]+200), ', deriv1[', (w_poly_peaks[i]-200), ':', (w_poly_peaks[i]+200), '], type = "l") ,', 'wave', i, 'removed')
         printed <- 1 
         artefacts[length(artefacts) + 1] <- i
       }
    }
}                                                                                                                         
w_poly_peaks_yval <- predict(d1p, w_poly_peaks)                                                                                                              
w_poly_peaks_yval_deriv1 <- predict(d1p, w_poly_peaks)
Ws <- data.frame(w_poly_peaks, w_poly_peaks_yval, w_poly_peaks_yval_deriv1)
Ws <- Ws[-artefacts, ]
 return(Ws)
}
